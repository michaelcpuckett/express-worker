{"mappings":"AAQA;IAEc,QAAQ,CAAC,KAAK,EAAE,OAAO;IADnC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAM;gBACf,KAAK,EAAE,OAAO;CACpC;AAKD;IAEE,KAAK,UAAS;IASd,IAAI,CAAC,IAAI,EAAE,MAAM;IAOjB,IAAI,CAAC,IAAI,EAAE,MAAM;IAOjB,IAAI,CAAC,IAAI,EAAE,OAAO;IAUlB,IAAI,CAAC,IAAI,EAAE,IAAI;IAUf,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO;IAgB3B,MAAM,CAAC,IAAI,EAAE,MAAM;IAMnB,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;IAM9B,GAAG;IAMH,QAAQ,CAAC,GAAG,EAAE,MAAM;IAMpB,WAAW;CAUZ;AAKD,mCAAmC,OAAO,GAAG;IAC3C,KAAK,EAAE,qBAAqB,CAAC;IAC7B,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CAChC,CAAC;AAKF;IACE,CAAC,GAAG,EAAE,oBAAoB,EAAE,GAAG,EAAE,qBAAqB,GAAG,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CAC/E;AAuCD;IAEE,MAAM,UAAS;gBAqBH,OAAO,CAAC,EAAE;QAAE,KAAK,CAAC,EAAE,OAAO,CAAA;KAAE;IAUzC,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAK/C,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAKhD,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAK/C,KAAK,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAKjD,MAAM,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAKlD,GAAG,CAAC,OAAO,EAAE,oBAAoB;IAK3B,aAAa,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAuFpD,WAAW,CAAC,KAAK,EAAE,KAAK;IAaxB,YAAY,CACV,MAAM,EAAE,MAAM,GACb,MAAM,IAAI,KAAK,GAAG,MAAM,GAAG,OAAO,GAAG,KAAK,GAAG,QAAQ;IAWxD,OAAO;IAcP,MAAM,CAAC,gCAAgC,CAAC,CAAC,SAAS,MAAM,EACtD,OAAO,EAAE,CACP,GAAG,EAAE,oBAAoB,GAAG,CAAC,EAC7B,GAAG,EAAE,qBAAqB,KACvB,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,SAEN,oBAAoB,OAAO,qBAAqB;CAItE","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { Key, pathToRegexp } from 'path-to-regexp';\r\n\r\n/**\r\n * Wraps the native Request object and adds the `params` object.\r\n *\r\n * This will be wrapped in a Proxy to provide direct access to the\r\n * native Request object.\r\n **/\r\nexport class _ExpressWorkerRequest {\r\n  params: Record<string, string> = {};\r\n  constructor(readonly _self: Request) {}\r\n}\r\n\r\n/**\r\n * Provides an API for modifying the response before it is sent.\r\n */\r\nclass ExpressWorkerResponse {\r\n  /** Whether the response has been ended and should not be modified. */\r\n  ended = false;\r\n\r\n  private _body = '';\r\n  private _blob: Blob | null = null;\r\n  private _redirect = '';\r\n  private _headers = new Headers();\r\n  private _status = 200;\r\n\r\n  /* Populates the body and sets the `Content-Type` header to HTML. */\r\n  html(data: string) {\r\n    this._body = data;\r\n    this._headers.set('Content-Type', 'text/html');\r\n    return this;\r\n  }\r\n\r\n  /* Populates the body and sets the `Content-Type` header to text. */\r\n  text(data: string) {\r\n    this._body = data;\r\n    this._headers.set('Content-Type', 'text/plain');\r\n    return this;\r\n  }\r\n\r\n  /* Populates the body and sets the `Content-Type` header to JSON. */\r\n  json(data: unknown) {\r\n    this._body = JSON.stringify(data);\r\n    this._headers.set('Content-Type', 'application/json');\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Populates the body with a Blob and sets the `Content-Type` header to the\r\n   * Blob's type.\r\n   */\r\n  blob(blob: Blob) {\r\n    this._blob = blob;\r\n    this._headers.set('Content-Type', blob.type);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Populates the body, sets the appropriate `Content-Type` header, and ends\r\n   * the response.\r\n   **/\r\n  send(data: string | unknown) {\r\n    if (typeof data === 'string') {\r\n      if (!this._headers.has('Content-Type')) {\r\n        this.html(data);\r\n      } else {\r\n        this._body = data;\r\n      }\r\n    } else {\r\n      this.json(data);\r\n    }\r\n\r\n    this.end();\r\n    return this;\r\n  }\r\n\r\n  /** Sets the status code. */\r\n  status(code: number) {\r\n    this._status = code;\r\n    return this;\r\n  }\r\n\r\n  /** Sets a Header key-value pair. */\r\n  set(key: string, value: string) {\r\n    this._headers.set(key, value);\r\n    return this;\r\n  }\r\n\r\n  /** Ends the response. */\r\n  end() {\r\n    this.ended = true;\r\n    return this;\r\n  }\r\n\r\n  /** Mark the request as a redirect. */\r\n  redirect(url: string) {\r\n    this._redirect = url;\r\n    return this;\r\n  }\r\n\r\n  /** Generates a Response object from the ExpressWorkerResponse. */\r\n  _toResponse() {\r\n    if (this._redirect) {\r\n      return Response.redirect(this._redirect, 303);\r\n    }\r\n\r\n    return new Response(this._blob ?? this._body, {\r\n      status: this._status,\r\n      headers: this._headers,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * The type of the ExpressWorkerRequest object when wrapped in a Proxy.\r\n */\r\nexport type ExpressWorkerRequest = Request & {\r\n  _self: _ExpressWorkerRequest;\r\n  params: Record<string, string>;\r\n};\r\n\r\n/**\r\n * The handler function for `get`, `post`, `put`, `patch`, and `delete` methods.\r\n */\r\nexport interface ExpressWorkerHandler {\r\n  (req: ExpressWorkerRequest, res: ExpressWorkerResponse): void | Promise<void>;\r\n}\r\n\r\n/**\r\n * The way the requests are stored.\r\n *\r\n * The first element is the path, the second is the handler.\r\n */\r\ntype PathArray = [string, ExpressWorkerHandler][];\r\n\r\n/**\r\n * The options for the ExpressWorkerRequest Proxy. This allows direct access to\r\n * the native Request object, along with the `params` object.\r\n */\r\nconst requestProxyConfig: ProxyHandler<_ExpressWorkerRequest> = {\r\n  get: (target, key) => {\r\n    if (key === 'params') {\r\n      return target.params;\r\n    }\r\n\r\n    const value = target._self[key as keyof typeof target._self];\r\n\r\n    if (typeof value === 'function') {\r\n      return value.bind(target._self);\r\n    }\r\n\r\n    return target[key as keyof typeof target];\r\n  },\r\n};\r\n\r\n/**\r\n * Guards for whether a request is a proxied ExpressWorkerRequest.\r\n */\r\nfunction isReq(request: unknown): request is ExpressWorkerRequest {\r\n  return request instanceof _ExpressWorkerRequest;\r\n}\r\n\r\n/**\r\n * The main class for ExpressWorker.\r\n */\r\nexport class ExpressWorker {\r\n  /** Whether to display logs in the console. */\r\n  _debug = false;\r\n\r\n  /** The paths and handlers for each method. */\r\n  private paths: {\r\n    GET: PathArray;\r\n    POST: PathArray;\r\n    PATCH: PathArray;\r\n    PUT: PathArray;\r\n    DELETE: PathArray;\r\n    USE: ExpressWorkerHandler[];\r\n  } = {\r\n    GET: [],\r\n    POST: [],\r\n    PATCH: [],\r\n    PUT: [],\r\n    DELETE: [],\r\n    USE: [],\r\n  };\r\n\r\n  private boundFetchHandler = this.handleFetch.bind(this);\r\n\r\n  constructor(options?: { debug?: boolean }) {\r\n    self.addEventListener('fetch', this.boundFetchHandler);\r\n\r\n    if (options?.debug) {\r\n      this._debug = true;\r\n      console.log('ExpressWorker initialized');\r\n    }\r\n  }\r\n\r\n  /** Registers a GET event handler. */\r\n  get(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.GET.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a POST event handler. */\r\n  post(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.POST.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a PUT event handler. */\r\n  put(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.PUT.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a PATCH event handler. */\r\n  patch(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.PATCH.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a DELETE event handler. */\r\n  delete(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.DELETE.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a middleware handler. */\r\n  use(handler: ExpressWorkerHandler) {\r\n    this.paths.USE.push(handler.bind(this));\r\n  }\r\n\r\n  /** Processes a request and returns a response. */\r\n  async handleRequest(event: Event): Promise<Response> {\r\n    if (!(event instanceof FetchEvent)) {\r\n      throw new Error('Event must be a FetchEvent');\r\n    }\r\n\r\n    const request = event.request;\r\n\r\n    const req = new Proxy(\r\n      new _ExpressWorkerRequest(request),\r\n      requestProxyConfig,\r\n    );\r\n\r\n    const res = new ExpressWorkerResponse();\r\n\r\n    if (!isReq(req)) {\r\n      throw new Error('Request must be a proxied ExpressWorkerRequest.');\r\n    }\r\n\r\n    for (const middleware of this.paths.USE) {\r\n      await middleware(req, res);\r\n\r\n      if (res.ended) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    let hasBeenHandled = false;\r\n\r\n    if (!this.isMethodEnum(request.method)) {\r\n      throw new Error('Must be a valid method.');\r\n    }\r\n\r\n    for (const [path, handler] of this.paths[request.method]) {\r\n      if (res.ended) {\r\n        break;\r\n      }\r\n\r\n      if (path === '*') {\r\n        continue;\r\n      }\r\n\r\n      const keys: Key[] = [];\r\n      const match = pathToRegexp(path, keys).exec(\r\n        new URL(request.url).pathname,\r\n      );\r\n\r\n      if (!match) {\r\n        continue;\r\n      }\r\n\r\n      const params = Object.fromEntries(\r\n        keys\r\n          .map((key, index) => [key.name, match?.[index + 1]])\r\n          .filter(Boolean),\r\n      );\r\n\r\n      req.params = params;\r\n\r\n      await handler(req, res);\r\n\r\n      hasBeenHandled = true;\r\n    }\r\n\r\n    if (!hasBeenHandled) {\r\n      for (const [path, handler] of this.paths[request.method]) {\r\n        if (res.ended) {\r\n          break;\r\n        }\r\n\r\n        if (path !== '*') {\r\n          continue;\r\n        }\r\n\r\n        await handler(req, res);\r\n\r\n        hasBeenHandled = true;\r\n      }\r\n    }\r\n\r\n    if (!hasBeenHandled) {\r\n      return fetch(request);\r\n    }\r\n\r\n    return res._toResponse();\r\n  }\r\n\r\n  /** Handles the fetch event. */\r\n  handleFetch(event: Event) {\r\n    if (!(event instanceof FetchEvent)) {\r\n      throw new Error('ExpressWorkerApp must be initialized with a FetchEvent');\r\n    }\r\n\r\n    if (!this.isMethodEnum(event.request.method)) {\r\n      return;\r\n    }\r\n\r\n    return event.respondWith(this.handleRequest(event));\r\n  }\r\n\r\n  /** Checks whether a method is a valid HTTP method. */\r\n  isMethodEnum(\r\n    method: string,\r\n  ): method is 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE' {\r\n    return (\r\n      method === 'GET' ||\r\n      method === 'POST' ||\r\n      method === 'PATCH' ||\r\n      method === 'PUT' ||\r\n      method === 'DELETE'\r\n    );\r\n  }\r\n\r\n  /** Resets the paths. For use in tests only. */\r\n  __reset() {\r\n    this.paths = {\r\n      GET: [],\r\n      POST: [],\r\n      PATCH: [],\r\n      PUT: [],\r\n      DELETE: [],\r\n      USE: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a modified handler that includes any middleware properties.\r\n   */\r\n  static applyAdditionalRequestProperties<T extends Object>(\r\n    handler: (\r\n      req: ExpressWorkerRequest & T,\r\n      res: ExpressWorkerResponse,\r\n    ) => void | Promise<void>,\r\n  ) {\r\n    return async (req: ExpressWorkerRequest, res: ExpressWorkerResponse) => {\r\n      return await handler(req as ExpressWorkerRequest & T, res);\r\n    };\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"express-worker.d.ts.map"}