{"mappings":"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","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { Key, pathToRegexp } from 'path-to-regexp';\n\n/**\n * Wraps the native Request object and adds the `params` object.\n * This will be wrapped in a Proxy to provide the default API.\n **/\nexport class _ExpressWorkerRequest {\n  _self: Request;\n  params: Record<string, string> = {};\n\n  constructor(_self: Request) {\n    this._self = _self;\n  }\n}\n\n/**\n * Extends the native Response object and adds familiar Express-style methods.\n */\nclass _ExpressWorkerResponse extends Response {\n  _body = '';\n  _blob: Blob | null = null;\n  _redirect = '';\n  _ended = false;\n  _headers = new Headers();\n  _status = 200;\n\n  __html(data: string) {\n    this._body = data;\n    this._headers.set('Content-Type', 'text/html');\n    return this;\n  }\n\n  __text(data: string) {\n    this._body = data;\n    this._headers.set('Content-Type', 'text/plain');\n    return this;\n  }\n\n  __json(data: unknown) {\n    this._body = JSON.stringify(data);\n    this._headers.set('Content-Type', 'application/json');\n    return this;\n  }\n\n  __blob(blob: Blob) {\n    this._blob = blob;\n    this._headers.set('Content-Type', blob.type);\n    return this;\n  }\n\n  __send(data: string | unknown) {\n    if (typeof data === 'string') {\n      if (!this._headers.has('Content-Type')) {\n        this.__html(data);\n      } else {\n        this._body = data;\n      }\n    } else {\n      this.__json(data);\n    }\n\n    this.end();\n    return this;\n  }\n\n  __status(code: number) {\n    this._status = code;\n    return this;\n  }\n\n  set(key: string, value: string) {\n    this._headers.set(key, value);\n    return this;\n  }\n\n  end() {\n    this._ended = true;\n    return this;\n  }\n\n  redirect(url: string) {\n    this._redirect = url;\n    return this;\n  }\n}\n\n/**\n * The type of the ExpressWorkerRequest object when wrapped in a Proxy.\n */\nexport type ExpressWorkerRequest = Omit<Request, 'body'> & {\n  _self: _ExpressWorkerRequest;\n  body: string;\n  params: Record<string, string>;\n};\n\n/**\n * The type of the ExpressWorkerResponse object when wrapped in a Proxy.\n */\nexport type ExpressWorkerResponse = Omit<\n  _ExpressWorkerResponse,\n  'body' | 'headers'\n> & {\n  _self: _ExpressWorkerResponse;\n  body: string;\n  headers: Headers;\n  status: number | ((code: number) => ExpressWorkerResponse);\n  set: (key: string, value: string) => ExpressWorkerResponse;\n  html: (data: string) => ExpressWorkerResponse;\n  text: (data: string) => ExpressWorkerResponse;\n  json: (data: unknown) => ExpressWorkerResponse;\n  blob: (blob: Blob) => _ExpressWorkerResponse;\n  send: (data: string | unknown) => ExpressWorkerResponse;\n};\n\n/**\n * The handler function for `get`, `post`, `put`, `patch`, and `delete` methods.\n */\nexport interface ExpressWorkerHandler {\n  (req: ExpressWorkerRequest, res: ExpressWorkerResponse): void | Promise<void>;\n}\n\n/**\n * The way the requests are stored.\n *\n * The first element is the path, the second is the handler.\n */\ntype PathArray = [string, ExpressWorkerHandler][];\n\n/**\n * The options for the ExpressWorkerRequest Proxy.\n */\nconst requestProxyConfig: ProxyHandler<_ExpressWorkerRequest> = {\n  get: (target, key) => {\n    if (key === 'params') {\n      return target.params;\n    }\n\n    const value = target._self[key];\n\n    if (typeof value === 'function') {\n      return target._self[key].bind(target._self);\n    }\n\n    return target[key];\n  },\n};\n\n/**\n * The options for the ExpressWorkerResponse Proxy.\n */\nconst responseProxyConfig: ProxyHandler<_ExpressWorkerResponse> = {\n  get: (target, key) => {\n    if (key === 'body') {\n      return target._body;\n    }\n\n    if (key === 'headers') {\n      return target._headers;\n    }\n\n    if (key === 'blob') {\n      return target.__blob;\n    }\n\n    if (key === 'html') {\n      return target.__html;\n    }\n\n    if (key === 'text') {\n      return target.__text;\n    }\n\n    if (key === 'json') {\n      return target.__json;\n    }\n\n    if (key === 'send') {\n      return target.__send;\n    }\n\n    if (key === 'status') {\n      return target.__status;\n    }\n\n    if (key === '_self') {\n      return target;\n    }\n\n    return target[key];\n  },\n  set: (target, key, value) => {\n    if (key === 'status') {\n      target.__status(value);\n    } else if (key === 'body') {\n      target._body = value;\n    } else {\n      target[key] = value;\n    }\n\n    return true;\n  },\n};\n\n/**\n * Guards for whether a request is an ExpressWorkerRequest.\n */\nfunction isModifiedRequest(request: unknown): request is ExpressWorkerRequest {\n  return request instanceof _ExpressWorkerRequest && 'params' in request;\n}\n\n/**\n * Guards for whether a response is an ExpressWorkerResponse.\n */\nfunction isModifiedResponse(\n  response: unknown,\n): response is ExpressWorkerResponse {\n  return (\n    response instanceof _ExpressWorkerResponse &&\n    '_body' in response &&\n    '_headers' in response\n  );\n}\n\n/**\n * The main class for ExpressWorker.\n */\nexport class ExpressWorker {\n  /** Whether to display logs in the console. */\n  _debug = false;\n\n  /** Whether to forward requests to the network. */\n  _forward = false;\n\n  /** The paths and handlers for each method. */\n  private paths: {\n    GET: PathArray;\n    POST: PathArray;\n    PATCH: PathArray;\n    PUT: PathArray;\n    DELETE: PathArray;\n    USE: ExpressWorkerHandler[];\n  } = {\n    GET: [],\n    POST: [],\n    PATCH: [],\n    PUT: [],\n    DELETE: [],\n    USE: [],\n  };\n\n  private boundFetchHandler = this.handleFetch.bind(this);\n\n  constructor(options?: { debug?: boolean; forward?: boolean }) {\n    self.addEventListener('fetch', this.boundFetchHandler);\n\n    if (options?.debug) {\n      this._debug = true;\n      console.log('ExpressWorker initialized');\n    }\n\n    if (options?.forward) {\n      this._forward = true;\n    }\n  }\n\n  /** Registers a GET event handler. */\n  get(path: string, handler: ExpressWorkerHandler) {\n    this.paths.GET.push([path, handler]);\n  }\n\n  /** Registers a POST event handler. */\n  post(path: string, handler: ExpressWorkerHandler) {\n    this.paths.POST.push([path, handler]);\n  }\n\n  /** Registers a PUT event handler. */\n  put(path: string, handler: ExpressWorkerHandler) {\n    this.paths.PUT.push([path, handler]);\n  }\n\n  /** Registers a PATCH event handler. */\n  patch(path: string, handler: ExpressWorkerHandler) {\n    this.paths.PATCH.push([path, handler]);\n  }\n\n  /** Registers a DELETE event handler. */\n  delete(path: string, handler: ExpressWorkerHandler) {\n    this.paths.DELETE.push([path, handler]);\n  }\n\n  /** Registers a middleware handler. */\n  use(handler: ExpressWorkerHandler) {\n    this.paths.USE.push(handler.bind(this));\n  }\n\n  /** Processes a request and returns a response. */\n  async handleRequest(event: Event): Promise<Response> {\n    if (!(event instanceof FetchEvent)) {\n      throw new Error('Event must be a FetchEvent');\n    }\n\n    const request = event.request;\n\n    const req = new Proxy(\n      new _ExpressWorkerRequest(request),\n      requestProxyConfig,\n    );\n\n    const res = new Proxy(new _ExpressWorkerResponse(), responseProxyConfig);\n\n    if (!isModifiedRequest(req)) {\n      throw new Error('Request must be a modified request');\n    }\n\n    if (!isModifiedResponse(res)) {\n      throw new Error('Response must be a modified response');\n    }\n\n    for (const middleware of this.paths.USE) {\n      await middleware(req, res);\n\n      if (res._ended) {\n        break;\n      }\n    }\n\n    let hasBeenHandled = false;\n\n    for (const [path, handler] of this.paths[request.method]) {\n      if (res._ended) {\n        break;\n      }\n\n      if (path === '*') {\n        continue;\n      }\n\n      const keys: Key[] = [];\n      const match = pathToRegexp(path, keys).exec(\n        new URL(request.url).pathname,\n      );\n\n      if (!match) {\n        continue;\n      }\n\n      const params = Object.fromEntries(\n        keys\n          .map((key, index) => [key.name, match?.[index + 1]])\n          .filter(Boolean),\n      );\n\n      req.params = params;\n\n      await handler(req, res);\n\n      hasBeenHandled = true;\n    }\n\n    if (!hasBeenHandled) {\n      for (const [path, handler] of this.paths[request.method]) {\n        if (res._ended) {\n          break;\n        }\n\n        if (path !== '*') {\n          continue;\n        }\n\n        await handler(req, res);\n\n        hasBeenHandled = true;\n      }\n    }\n\n    if (!hasBeenHandled) {\n      if (this._forward) {\n        return fetch(request);\n      }\n\n      return new Response('Not Found', { status: 404 });\n    }\n\n    const { _body, _status, _headers, _blob, _redirect } = res;\n\n    if (this._debug) {\n      console.log(this, req._self, res._self);\n    }\n\n    if (_redirect) {\n      return Response.redirect(_redirect, 303);\n    }\n\n    const content = _blob || _body || '';\n\n    return new Response(content, {\n      status: _status,\n      headers: _headers,\n    });\n  }\n\n  /** Handles the fetch event. */\n  handleFetch(event: Event) {\n    if (!(event instanceof FetchEvent)) {\n      throw new Error('ExpressWorkerApp must be initialized with a FetchEvent');\n    }\n\n    if (!this.isMethodEnum(event.request.method)) {\n      return;\n    }\n\n    return event.respondWith(this.handleRequest(event));\n  }\n\n  /** Checks whether a method is a valid HTTP method. */\n  isMethodEnum(\n    method: string,\n  ): method is 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE' {\n    return (\n      method === 'GET' ||\n      method === 'POST' ||\n      method === 'PATCH' ||\n      method === 'PUT' ||\n      method === 'DELETE'\n    );\n  }\n\n  /** Resets the paths. For use in tests only. */\n  __reset() {\n    this.paths = {\n      GET: [],\n      POST: [],\n      PATCH: [],\n      PUT: [],\n      DELETE: [],\n      USE: [],\n    };\n  }\n}\n\n/**\n * Generate a modified handler that includes any middleware properties.\n */\nexport function applyAdditionalRequestProperties<T extends Object>(\n  handler: (\n    req: ExpressWorkerRequest & T,\n    res: ExpressWorkerResponse,\n  ) => void | Promise<void>,\n) {\n  return async (req: ExpressWorkerRequest, res: ExpressWorkerResponse) => {\n    return await handler(req as ExpressWorkerRequest & T, res);\n  };\n}\n"],"names":[],"version":3,"file":"express-worker.d.ts.map"}