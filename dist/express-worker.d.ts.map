{"mappings":"AAEA,iCAAkC,SAAQ,OAAO;IAC/C,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAM;CACrC;AAED,oCAA6B,SAAQ,QAAQ;IAC3C,KAAK,SAAM;IACX,QAAQ,UAAiB;IACzB,MAAM,UAAS;IACf,MAAM,SAAO;IAEb,GAAG;CAGJ;AAED,oCAAoC,IAAI,CACtC,sBAAsB,EACtB,MAAM,GAAG,SAAS,CACnB,GAAG;IACF,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,OAAO,CAAC;CAClB,CAAC;AAEF;IACE,CAAC,GAAG,EAAE,oBAAoB,EAAE,GAAG,EAAE,qBAAqB,GAAG,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CAC/E;AAqCD;;IAiBE,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAI/C,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAIhD,GAAG,CAAC,OAAO,EAAE,oBAAoB;IAgDjC,WAAW,CAAC,KAAK,EAAE,KAAK;IAgBxB,YAAY,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,IAAI,KAAK,GAAG,MAAM;CAGvD;AAED,iDAAiD,CAAC,SAAS,MAAM,EAC/D,OAAO,EAAE,CACP,GAAG,EAAE,oBAAoB,GAAG,CAAC,EAC7B,GAAG,EAAE,qBAAqB,KACvB,OAAO,CAAC,IAAI,CAAC,SAEC,oBAAoB,OAAO,qBAAqB,mBAGpE","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { pathToRegexp } from 'path-to-regexp';\r\n\r\nexport class ExpressWorkerRequest extends Request {\r\n  params: Record<string, string> = {};\r\n}\r\n\r\nclass _ExpressWorkerResponse extends Response {\r\n  _body = '';\r\n  _headers = new Headers();\r\n  _ended = false;\r\n  status = 200;\r\n\r\n  end() {\r\n    this._ended = true;\r\n  }\r\n}\r\n\r\nexport type ExpressWorkerResponse = Omit<\r\n  _ExpressWorkerResponse,\r\n  'body' | 'headers'\r\n> & {\r\n  body: string;\r\n  headers: Headers;\r\n};\r\n\r\nexport interface ExpressWorkerHandler {\r\n  (req: ExpressWorkerRequest, res: ExpressWorkerResponse): void | Promise<void>;\r\n}\r\n\r\ntype PathArray = [string, ExpressWorkerHandler][];\r\n\r\nconst proxyConfig: ProxyHandler<_ExpressWorkerResponse> = {\r\n  get: (target, key) => {\r\n    if (key === 'body') {\r\n      return target._body;\r\n    }\r\n\r\n    if (key === 'headers') {\r\n      return target._headers;\r\n    }\r\n\r\n    return target[key];\r\n  },\r\n  set: (target, key, value) => {\r\n    if (key === 'body') {\r\n      target._body = value;\r\n    } else {\r\n      target[key] = value;\r\n    }\r\n\r\n    return true;\r\n  },\r\n};\r\n\r\nfunction isModifiedResponse(\r\n  response: unknown,\r\n): response is ExpressWorkerResponse {\r\n  return (\r\n    response instanceof _ExpressWorkerResponse &&\r\n    '_body' in response &&\r\n    '_headers' in response\r\n  );\r\n}\r\n\r\nexport class ExpressWorker {\r\n  private paths: {\r\n    GET: PathArray;\r\n    POST: PathArray;\r\n    USE: ExpressWorkerHandler[];\r\n  } = {\r\n    GET: [],\r\n    POST: [],\r\n    USE: [],\r\n  };\r\n\r\n  private boundFetchHandler = this.handleFetch.bind(this);\r\n\r\n  constructor() {\r\n    self.addEventListener('fetch', this.boundFetchHandler);\r\n  }\r\n\r\n  get(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.GET.push([path, handler]);\r\n  }\r\n\r\n  post(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.POST.push([path, handler]);\r\n  }\r\n\r\n  use(handler: ExpressWorkerHandler) {\r\n    this.paths.USE.push(handler);\r\n  }\r\n\r\n  private async handleRequest(request: Request): Promise<Response> {\r\n    for (const [path, handler] of this.paths[request.method]) {\r\n      const match = pathToRegexp(path).exec(new URL(request.url).pathname);\r\n\r\n      if (match) {\r\n        const req = new ExpressWorkerRequest(request.url, {\r\n          method: request.method,\r\n          headers: request.headers,\r\n        });\r\n\r\n        if (match.groups) {\r\n          req.params = match.groups;\r\n        }\r\n\r\n        const res = new Proxy(new _ExpressWorkerResponse(), proxyConfig);\r\n\r\n        if (!isModifiedResponse(res)) {\r\n          throw new Error('Response must be a modified response');\r\n        }\r\n\r\n        for (const middleware of this.paths.USE) {\r\n          await middleware(req, res);\r\n\r\n          if (res._ended) {\r\n            continue;\r\n          }\r\n        }\r\n\r\n        if (!res._ended) {\r\n          await handler(req, res);\r\n        }\r\n\r\n        const { body, status, headers } = res;\r\n\r\n        return new Response(body, {\r\n          status,\r\n          headers,\r\n        });\r\n      }\r\n    }\r\n\r\n    return new Response('Not found', { status: 404 });\r\n  }\r\n\r\n  handleFetch(event: Event) {\r\n    if (!(event instanceof FetchEvent)) {\r\n      throw new Error('ExpressWorkerApp must be initialized with a FetchEvent');\r\n    }\r\n\r\n    return event.respondWith(\r\n      (async () => {\r\n        if (!this.isMethodEnum(event.request.method)) {\r\n          throw new Error(`Unsupported method: ${event.request.method}`);\r\n        }\r\n\r\n        return await this.handleRequest(event.request);\r\n      })(),\r\n    );\r\n  }\r\n\r\n  isMethodEnum(method: string): method is 'GET' | 'POST' {\r\n    return method === 'GET' || method === 'POST';\r\n  }\r\n}\r\n\r\nexport function applyAdditionalRequestProperties<T extends Object>(\r\n  handler: (\r\n    req: ExpressWorkerRequest & T,\r\n    res: ExpressWorkerResponse,\r\n  ) => Promise<void>,\r\n) {\r\n  return async (req: ExpressWorkerRequest, res: ExpressWorkerResponse) => {\r\n    return await handler(req as ExpressWorkerRequest & T, res);\r\n  };\r\n}\r\n"],"names":[],"version":3,"file":"express-worker.d.ts.map"}