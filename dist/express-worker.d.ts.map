{"mappings":"AAMA;IACE,KAAK,EAAE,OAAO,CAAC;IACf,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAM;gBAExB,KAAK,EAAE,OAAO;CAG3B;AAKD,oCAA6B,SAAQ,QAAQ;IAC3C,KAAK,SAAM;IACX,KAAK,EAAE,IAAI,GAAG,IAAI,CAAQ;IAC1B,SAAS,SAAM;IACf,MAAM,UAAS;IACf,QAAQ,UAAiB;IAEzB,MAAM,SAAO;IAEb,MAAM,CAAC,IAAI,EAAE,MAAM;IAKnB,MAAM,CAAC,IAAI,EAAE,MAAM;IAKnB,MAAM,CAAC,IAAI,EAAE,OAAO;IAKpB,MAAM,CAAC,IAAI,EAAE,IAAI;IAKjB,MAAM,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO;IAc7B,GAAG;IAIH,QAAQ,CAAC,GAAG,EAAE,MAAM;CAGrB;AAKD,oCAAoC,IAAI,CACtC,sBAAsB,EACtB,MAAM,GAAG,SAAS,CACnB,GAAG;IACF,KAAK,EAAE,sBAAsB,CAAC;IAC9B,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,OAAO,CAAC;IACjB,GAAG,EAAE,MAAM,CAAC;IACZ,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC;IAClC,WAAW,EAAE,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC;IACxC,IAAI,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,IAAI,CAAC;IAC7B,IAAI,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,IAAI,CAAC;IAC7B,IAAI,EAAE,CAAC,IAAI,EAAE,OAAO,KAAK,IAAI,CAAC;IAC9B,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,CAAC;IAC3B,IAAI,EAAE,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,KAAK,IAAI,CAAC;CACxC,CAAC;AAKF,mCAAmC,IAAI,CAAC,qBAAqB,EAAE,MAAM,CAAC,GAAG;IACvE,KAAK,EAAE,qBAAqB,CAAC;IAC7B,IAAI,EAAE,MAAM,CAAC;CACd,CAAC;AAKF;IACE,CAAC,GAAG,EAAE,oBAAoB,EAAE,GAAG,EAAE,qBAAqB,GAAG,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CAC/E;AA+HD;gBAuBc,OAAO,CAAC,EAAE;QAAE,KAAK,CAAC,EAAE,OAAO,CAAA;KAAE;IAUzC,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAK/C,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAKhD,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAK/C,KAAK,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAKjD,MAAM,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAKlD,GAAG,CAAC,OAAO,EAAE,oBAAoB;IAK3B,aAAa,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IA8EpD,WAAW,CAAC,KAAK,EAAE,KAAK;IAaxB,YAAY,CACV,MAAM,EAAE,MAAM,GACb,MAAM,IAAI,KAAK,GAAG,MAAM,GAAG,OAAO,GAAG,KAAK,GAAG,QAAQ;IAWxD,OAAO;CAUR;AAKD,iDAAiD,CAAC,SAAS,MAAM,EAC/D,OAAO,EAAE,CACP,GAAG,EAAE,oBAAoB,GAAG,CAAC,EAC7B,GAAG,EAAE,qBAAqB,KACvB,OAAO,CAAC,IAAI,CAAC,SAEC,oBAAoB,OAAO,qBAAqB,mBAGpE","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { Key, pathToRegexp } from 'path-to-regexp';\r\n\r\n/**\r\n * Wraps the native Request object and adds the `params` object.\r\n * This will be wrapped in a Proxy to provide the default API.\r\n **/\r\nexport class _ExpressWorkerRequest {\r\n  _self: Request;\r\n  params: Record<string, string> = {};\r\n\r\n  constructor(_self: Request) {\r\n    this._self = _self;\r\n  }\r\n}\r\n\r\n/**\r\n * Extends the native Response object and adds familiar Express-style methods.\r\n */\r\nclass _ExpressWorkerResponse extends Response {\r\n  _body = '';\r\n  _blob: Blob | null = null;\r\n  _redirect = '';\r\n  _ended = false;\r\n  _headers = new Headers();\r\n\r\n  status = 200;\r\n\r\n  __html(data: string) {\r\n    this._body = data;\r\n    this._headers.set('Content-Type', 'text/html');\r\n  }\r\n\r\n  __text(data: string) {\r\n    this._body = data;\r\n    this._headers.set('Content-Type', 'text/plain');\r\n  }\r\n\r\n  __json(data: unknown) {\r\n    this._body = JSON.stringify(data);\r\n    this._headers.set('Content-Type', 'application/json');\r\n  }\r\n\r\n  __blob(blob: Blob) {\r\n    this._blob = blob;\r\n    this._headers.set('Content-Type', blob.type);\r\n  }\r\n\r\n  __send(data: string | unknown) {\r\n    if (typeof data === 'string') {\r\n      if (!this._headers.has('Content-Type')) {\r\n        this.__html(data);\r\n      } else {\r\n        this._body = data;\r\n      }\r\n    } else {\r\n      this.__json(data);\r\n    }\r\n\r\n    this.end();\r\n  }\r\n\r\n  end() {\r\n    this._ended = true;\r\n  }\r\n\r\n  redirect(url: string) {\r\n    this._redirect = url;\r\n  }\r\n}\r\n\r\n/**\r\n * The type of the ExpressWorkerResponse object when wrapped in a Proxy.\r\n */\r\nexport type ExpressWorkerResponse = Omit<\r\n  _ExpressWorkerResponse,\r\n  'body' | 'headers'\r\n> & {\r\n  _self: _ExpressWorkerResponse;\r\n  body: string;\r\n  headers: Headers;\r\n  url: string;\r\n  method: string;\r\n  formData: () => Promise<FormData>;\r\n  arrayBuffer: () => Promise<ArrayBuffer>;\r\n  html: (data: string) => void;\r\n  text: (data: string) => void;\r\n  json: (data: unknown) => void;\r\n  blob: (blob: Blob) => void;\r\n  send: (data: string | unknown) => void;\r\n};\r\n\r\n/**\r\n * The type of the ExpressWorkerRequest object when wrapped in a Proxy.\r\n */\r\nexport type ExpressWorkerRequest = Omit<_ExpressWorkerRequest, 'body'> & {\r\n  _self: _ExpressWorkerRequest;\r\n  body: string;\r\n};\r\n\r\n/**\r\n * The handler function for `get`, `post`, `put`, `patch`, and `delete` methods.\r\n */\r\nexport interface ExpressWorkerHandler {\r\n  (req: ExpressWorkerRequest, res: ExpressWorkerResponse): void | Promise<void>;\r\n}\r\n\r\n/**\r\n * The way the requests are stored.\r\n *\r\n * The first element is the path, the second is the handler.\r\n */\r\ntype PathArray = [string, ExpressWorkerHandler][];\r\n\r\n/**\r\n * The options for the ExpressWorkerRequest Proxy.\r\n */\r\nconst requestProxyConfig: ProxyHandler<_ExpressWorkerRequest> = {\r\n  get: (target, key) => {\r\n    if (key === 'formData') {\r\n      return target._self.formData.bind(target._self);\r\n    }\r\n\r\n    if (key === 'blob') {\r\n      return target._self.blob.bind(target._self);\r\n    }\r\n\r\n    if (key === 'json') {\r\n      return target._self.json.bind(target._self);\r\n    }\r\n\r\n    if (key === 'text') {\r\n      return target._self.text.bind(target._self);\r\n    }\r\n\r\n    if (key === 'arrayBuffer') {\r\n      return target._self.arrayBuffer.bind(target._self);\r\n    }\r\n\r\n    if (key === 'body') {\r\n      return target._self.body;\r\n    }\r\n\r\n    if (key === 'headers') {\r\n      return target._self.headers;\r\n    }\r\n\r\n    if (key === 'url') {\r\n      return target._self.url;\r\n    }\r\n\r\n    if (key === 'method') {\r\n      return target._self.method;\r\n    }\r\n\r\n    return target[key];\r\n  },\r\n};\r\n\r\n/**\r\n * The options for the ExpressWorkerResponse Proxy.\r\n */\r\nconst responseProxyConfig: ProxyHandler<_ExpressWorkerResponse> = {\r\n  get: (target, key) => {\r\n    if (key === 'body') {\r\n      return target._body;\r\n    }\r\n\r\n    if (key === 'headers') {\r\n      return target._headers;\r\n    }\r\n\r\n    if (key === 'blob') {\r\n      return target.__blob;\r\n    }\r\n\r\n    if (key === 'html') {\r\n      return target.__html;\r\n    }\r\n\r\n    if (key === 'text') {\r\n      return target.__text;\r\n    }\r\n\r\n    if (key === 'json') {\r\n      return target.__json;\r\n    }\r\n\r\n    if (key === 'send') {\r\n      return target.__send;\r\n    }\r\n\r\n    if (key === '_self') {\r\n      return target;\r\n    }\r\n\r\n    return target[key];\r\n  },\r\n  set: (target, key, value) => {\r\n    if (key === 'body') {\r\n      target._body = value;\r\n    } else {\r\n      target[key] = value;\r\n    }\r\n\r\n    return true;\r\n  },\r\n};\r\n\r\n/**\r\n * Guards for whether a request is an ExpressWorkerRequest.\r\n */\r\nfunction isModifiedRequest(request: unknown): request is ExpressWorkerRequest {\r\n  return request instanceof _ExpressWorkerRequest && 'params' in request;\r\n}\r\n\r\n/**\r\n * Guards for whether a response is an ExpressWorkerResponse.\r\n */\r\nfunction isModifiedResponse(\r\n  response: unknown,\r\n): response is ExpressWorkerResponse {\r\n  return (\r\n    response instanceof _ExpressWorkerResponse &&\r\n    '_body' in response &&\r\n    '_headers' in response\r\n  );\r\n}\r\n\r\n/**\r\n * The main class for ExpressWorker.\r\n */\r\nexport class ExpressWorker {\r\n  /** Whether to display logs in the console. */\r\n  private debug = false;\r\n\r\n  /** The paths and handlers for each method. */\r\n  private paths: {\r\n    GET: PathArray;\r\n    POST: PathArray;\r\n    PATCH: PathArray;\r\n    PUT: PathArray;\r\n    DELETE: PathArray;\r\n    USE: ExpressWorkerHandler[];\r\n  } = {\r\n    GET: [],\r\n    POST: [],\r\n    PATCH: [],\r\n    PUT: [],\r\n    DELETE: [],\r\n    USE: [],\r\n  };\r\n\r\n  private boundFetchHandler = this.handleFetch.bind(this);\r\n\r\n  constructor(options?: { debug?: boolean }) {\r\n    self.addEventListener('fetch', this.boundFetchHandler);\r\n\r\n    if (options?.debug) {\r\n      this.debug = true;\r\n      console.log('ExpressWorker initialized');\r\n    }\r\n  }\r\n\r\n  /** Registers a GET event handler. */\r\n  get(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.GET.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a POST event handler. */\r\n  post(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.POST.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a PUT event handler. */\r\n  put(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.PUT.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a PATCH event handler. */\r\n  patch(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.PATCH.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a DELETE event handler. */\r\n  delete(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.DELETE.push([path, handler]);\r\n  }\r\n\r\n  /** Registers a middleware handler. */\r\n  use(handler: ExpressWorkerHandler) {\r\n    this.paths.USE.push(handler.bind(this));\r\n  }\r\n\r\n  /** Processes a request and returns a response. */\r\n  async handleRequest(event: Event): Promise<Response> {\r\n    if (!(event instanceof FetchEvent)) {\r\n      throw new Error('Event must be a FetchEvent');\r\n    }\r\n\r\n    const request = event.request;\r\n\r\n    const req = new Proxy(\r\n      new _ExpressWorkerRequest(request),\r\n      requestProxyConfig,\r\n    );\r\n\r\n    const res = new Proxy(new _ExpressWorkerResponse(), responseProxyConfig);\r\n\r\n    if (!isModifiedRequest(req)) {\r\n      throw new Error('Request must be a modified request');\r\n    }\r\n\r\n    if (!isModifiedResponse(res)) {\r\n      throw new Error('Response must be a modified response');\r\n    }\r\n\r\n    for (const middleware of this.paths.USE) {\r\n      await middleware(req, res);\r\n\r\n      if (res._ended) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    for (const [path, handler] of this.paths[request.method]) {\r\n      if (res._ended) {\r\n        continue;\r\n      }\r\n\r\n      const keys: Key[] = [];\r\n      const match = pathToRegexp(path, keys).exec(\r\n        new URL(request.url).pathname,\r\n      );\r\n\r\n      if (!match) {\r\n        continue;\r\n      }\r\n\r\n      const params = Object.fromEntries(\r\n        keys\r\n          .map((key, index) => [key.name, match?.[index + 1]])\r\n          .filter(Boolean),\r\n      );\r\n\r\n      req.params = params;\r\n\r\n      await handler(req, res);\r\n    }\r\n\r\n    const { _body, status, _headers, _blob, _redirect } = res;\r\n\r\n    if (this.debug) {\r\n      console.log(this, req._self, res._self);\r\n    }\r\n\r\n    if (_redirect) {\r\n      return Response.redirect(_redirect, 303);\r\n    }\r\n\r\n    const content = _body || _blob;\r\n\r\n    if (!content) {\r\n      return new Response('Not found', { status: 404 });\r\n    }\r\n\r\n    return new Response(content, {\r\n      status,\r\n      headers: _headers,\r\n    });\r\n  }\r\n\r\n  /** Handles the fetch event. */\r\n  handleFetch(event: Event) {\r\n    if (!(event instanceof FetchEvent)) {\r\n      throw new Error('ExpressWorkerApp must be initialized with a FetchEvent');\r\n    }\r\n\r\n    if (!this.isMethodEnum(event.request.method)) {\r\n      return;\r\n    }\r\n\r\n    return event.respondWith(this.handleRequest(event));\r\n  }\r\n\r\n  /** Checks whether a method is a valid HTTP method. */\r\n  isMethodEnum(\r\n    method: string,\r\n  ): method is 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE' {\r\n    return (\r\n      method === 'GET' ||\r\n      method === 'POST' ||\r\n      method === 'PATCH' ||\r\n      method === 'PUT' ||\r\n      method === 'DELETE'\r\n    );\r\n  }\r\n\r\n  /** Resets the paths. For use in tests only. */\r\n  __reset() {\r\n    this.paths = {\r\n      GET: [],\r\n      POST: [],\r\n      PATCH: [],\r\n      PUT: [],\r\n      DELETE: [],\r\n      USE: [],\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Generate a modified handler that includes any middleware properties.\r\n */\r\nexport function applyAdditionalRequestProperties<T extends Object>(\r\n  handler: (\r\n    req: ExpressWorkerRequest & T,\r\n    res: ExpressWorkerResponse,\r\n  ) => Promise<void>,\r\n) {\r\n  return async (req: ExpressWorkerRequest, res: ExpressWorkerResponse) => {\r\n    return await handler(req as ExpressWorkerRequest & T, res);\r\n  };\r\n}\r\n"],"names":[],"version":3,"file":"express-worker.d.ts.map"}