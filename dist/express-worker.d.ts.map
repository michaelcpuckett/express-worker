{"mappings":"AAEA;IACE,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC;CACxB;AAED,mCAAmC,OAAO,GAAG;IAC3C,MAAM,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CACjC,CAAC;AAEF,oCAAoC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,EAAE,QAAQ,CAAC,GAAG;IAC3E,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,GAAG,EAAE,MAAM,IAAI,CAAC;IAChB,MAAM,EAAE,OAAO,CAAC;CACjB,CAAC;AAEF;IACE,CAAC,GAAG,EAAE,oBAAoB,EAAE,GAAG,EAAE,qBAAqB,GAAG,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CAC/E;AAID;;IAiBE,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAI/C,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,oBAAoB;IAIhD,GAAG,CAAC,OAAO,EAAE,oBAAoB;IAwCjC,WAAW,CAAC,KAAK,EAAE,KAAK;IA8BxB,YAAY,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,IAAI,KAAK,GAAG,MAAM;CAGvD","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { pathToRegexp } from 'path-to-regexp';\r\n\r\nexport interface ExpressWorkerAdditionalParams {\r\n  [key: string]: unknown;\r\n}\r\n\r\nexport type ExpressWorkerRequest = Request & {\r\n  params?: Record<string, string>;\r\n};\r\n\r\nexport type ExpressWorkerResponse = Omit<Omit<Response, 'body'>, 'status'> & {\r\n  body: string;\r\n  status: number;\r\n  end: () => void;\r\n  _ended: boolean;\r\n};\r\n\r\nexport interface ExpressWorkerHandler {\r\n  (req: ExpressWorkerRequest, res: ExpressWorkerResponse): void | Promise<void>;\r\n}\r\n\r\ntype PathArray = [string, ExpressWorkerHandler][];\r\n\r\nexport class ExpressWorker {\r\n  private paths: {\r\n    GET: PathArray;\r\n    POST: PathArray;\r\n    USE: ExpressWorkerHandler[];\r\n  } = {\r\n    GET: [],\r\n    POST: [],\r\n    USE: [],\r\n  };\r\n\r\n  private boundFetchHandler = this.handleFetch.bind(this);\r\n\r\n  constructor() {\r\n    self.addEventListener('fetch', this.boundFetchHandler);\r\n  }\r\n\r\n  get(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.GET.push([path, handler]);\r\n  }\r\n\r\n  post(path: string, handler: ExpressWorkerHandler) {\r\n    this.paths.POST.push([path, handler]);\r\n  }\r\n\r\n  use(handler: ExpressWorkerHandler) {\r\n    this.paths.USE.push(handler);\r\n  }\r\n\r\n  private async handleRequest(\r\n    method: 'GET' | 'POST',\r\n    request: Request,\r\n    res: ExpressWorkerResponse,\r\n  ): Promise<Response> {\r\n    if (request.method === method) {\r\n      for (const [path, handler] of this.paths[method]) {\r\n        const match = pathToRegexp(path).exec(new URL(request.url).pathname);\r\n\r\n        if (match) {\r\n          const req: ExpressWorkerRequest = {\r\n            ...request,\r\n            params: match.groups,\r\n          };\r\n\r\n          for (const middleware of this.paths.USE) {\r\n            await middleware(req, res);\r\n\r\n            if (res._ended) {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (!res._ended) {\r\n            await handler(req, res);\r\n          }\r\n\r\n          const { body, ...responseInit } = res;\r\n          return new Response(body, responseInit);\r\n        }\r\n      }\r\n    }\r\n\r\n    return new Response('Not found', { status: 404 });\r\n  }\r\n\r\n  handleFetch(event: Event) {\r\n    if (!(event instanceof FetchEvent)) {\r\n      throw new Error('ExpressWorkerApp must be initialized with a FetchEvent');\r\n    }\r\n\r\n    const res: ExpressWorkerResponse = {\r\n      ...new Response(),\r\n      body: '',\r\n      status: 200,\r\n      _ended: false,\r\n      end() {\r\n        this._ended = true;\r\n      },\r\n    };\r\n\r\n    return event.respondWith(\r\n      (async () => {\r\n        if (!this.isMethodEnum(event.request.method)) {\r\n          throw new Error(`Unsupported method: ${event.request.method}`);\r\n        }\r\n\r\n        return await this.handleRequest(\r\n          event.request.method,\r\n          event.request,\r\n          res,\r\n        );\r\n      })(),\r\n    );\r\n  }\r\n\r\n  isMethodEnum(method: string): method is 'GET' | 'POST' {\r\n    return method === 'GET' || method === 'POST';\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"express-worker.d.ts.map"}